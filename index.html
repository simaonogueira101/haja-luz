<!DOCTYPE html>
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>TMD 2</title>
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="stylesheet" href="css/style-THREE.css">
		<link rel="stylesheet" href="css/style.css">
</head>


		<body>
			<div id="container">
				<div class="container-overlay" style="background: rgba(0,0,0,0); z-index: 200;">
					<div class="container-center">
						<a class="start-button" onclick="startButton(); backMusic();" id="start" href="#">
							<p>haja luz?</p>
						</a>
					</div>
				</div>
				<div class="container-overlay flash-overlay flash-start" id="flash"></div>
				<div class="container-overlay"></div>



				<canvas width="2880" height="1564" style="width: 1440px; height: 782px;"></canvas>
			</div>

			<div id="loading">Loading...</div>
			<div id="options">
				<a class="button" id="fullscreenBtn"></a>
			</div>
			<div id="switch">
			<a id="switchMaterial" class="button"></a></p>
			</div>

			<script src="./js/Three.js"></script>
			<script src="./js/MarchingCubes.js"></script>
			<script src="./js/Stats.js"></script>
			<script src="./js/ThreeRenderStats.js"></script>
			<script src="./js/ImprovedNoise.js"></script>

			<script type="x-shader/x-vertex" id="sphere-vs">
				void main() {
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}
			</script>

			<script type="x-shader/x-vertex" id="sphere-fs">
				uniform vec2 resolution;
				uniform float noise;
				uniform vec3 color;

				#define VIG_REDUCTION_POWER 1.
				#define VIG_BOOST 1.

				float random(vec3 scale,float seed){return fract(sin(dot(gl_FragCoord.xyz+seed,scale))*43758.5453+seed);}

				void main() {

					vec2 center = resolution * 0.5;
					float vignette = distance( center, gl_FragCoord.xy ) / resolution.x;
					vignette = VIG_BOOST - vignette * VIG_REDUCTION_POWER;

					float n = noise * ( .5 - random( vec3( 1. ), length( gl_FragCoord ) ) );

					float v = .5 * length( vec2( gl_FragCoord.y / resolution.y, ( 1. - abs( .5 - gl_FragCoord.x / resolution.x ) ) ) );
					vec3 base = color;
					base += vec3( pow( v, 2. ) );
					gl_FragColor = vec4( base * vec3( vignette ) + vec3( n ), 1. );

				}
			</script>

			<script type="x-shader/x-vertex" id="rim-vs">
				varying vec3 vNormal;
				varying vec3 vEye;

				void main() {

					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

					vNormal = normalize( normalMatrix * normal );
					vEye = ( modelViewMatrix * vec4( position, 1.0 ) ).xyz;

				}
			</script>

			<script type="x-shader/x-fragment" id="rim-fs">
				varying vec3 vNormal;
				varying vec3 vEye;

				void main() {

					float f = 2. * abs( dot( vNormal, normalize( vEye ) ) );
					f = .2 * ( 1. - smoothstep( 0.0, 1., f ) );
					gl_FragColor = vec4( 1., 1., 1., f );

				}
			</script>

			<script type="x-shader/x-vertex" id="vertexShader">
				varying vec3 vNormal;
		    varying vec4 vPosition;
		    varying vec4 vOPosition;
				varying vec3 vONormal;
		    varying vec3 vU;
		    varying vec3 vEye;

		    void main() {

		        vOPosition = modelViewMatrix * vec4( position, 1.0 );
		        gl_Position = projectionMatrix * vOPosition;

		        vU = normalize( vec3( modelViewMatrix * vec4( position, 1.0 ) ) );

		        vPosition = vec4( position, 1.0 );
		        vNormal = normalMatrix * normal;
		        vONormal = normal;

		    }
			</script>

			<script type="x-shader/x-vertex" id="fragmentShader">
				uniform sampler2D textureMap;
		    uniform sampler2D normalMap;
		    uniform vec3 color;
		    uniform float normalScale;
		    uniform float texScale;
		    uniform float useSSS;
		    uniform float useScreen;

		    varying vec3 vNormal;
		    varying vec4 vPosition;
		    varying vec4 vOPosition;
				varying vec3 vONormal;
				varying vec3 vU;
		    varying vec3 vEye;

				float random(vec3 scale,float seed){return fract(sin(dot(gl_FragCoord.xyz+seed,scale))*43758.5453+seed);}

			    void main() {

			        vec3 n = normalize( vONormal.xyz );
			        vec3 blend_weights = abs( n );
			        blend_weights = ( blend_weights - 0.2 ) * 7.;
			        blend_weights = max( blend_weights, 0. );
			        blend_weights /= ( blend_weights.x + blend_weights.y + blend_weights.z );

			        vec2 coord1 = vPosition.yz * texScale;
			        vec2 coord2 = vPosition.zx * texScale;
			        vec2 coord3 = vPosition.xy * texScale;

			        vec3 bump1 = texture2D( normalMap, coord1 ).rgb;
			        vec3 bump2 = texture2D( normalMap, coord2 ).rgb;
			        vec3 bump3 = texture2D( normalMap, coord3 ).rgb;

			        vec3 blended_bump = bump1 * blend_weights.xxx +
			                            bump2 * blend_weights.yyy +
			                            bump3 * blend_weights.zzz;

			        vec3 tanX = vec3( vNormal.x, -vNormal.z, vNormal.y);
			        vec3 tanY = vec3( vNormal.z, vNormal.y, -vNormal.x);
			        vec3 tanZ = vec3(-vNormal.y, vNormal.x, vNormal.z);
			        vec3 blended_tangent = tanX * blend_weights.xxx +
			                               tanY * blend_weights.yyy +
			                               tanZ * blend_weights.zzz;

			        vec3 normalTex = blended_bump * 2.0 - 1.0;
			        normalTex.xy *= normalScale;
			        normalTex.y *= -1.;
			        normalTex = normalize( normalTex );
			        mat3 tsb = mat3( normalize( blended_tangent ), normalize( cross( vNormal, blended_tangent ) ), normalize( vNormal ) );
			        vec3 finalNormal = tsb * normalTex;

			        vec3 r = reflect( normalize( vU ), normalize( finalNormal ) );
			        float m = 2.0 * sqrt( r.x * r.x + r.y * r.y + ( r.z + 1.0 ) * ( r.z + 1.0 ) );
			        vec2 calculatedNormal = vec2( r.x / m + 0.5,  r.y / m + 0.5 );

			        vec3 base = texture2D( textureMap, calculatedNormal ).rgb;

					float rim = 1.75 * max( 0., abs( dot( normalize( vNormal ), normalize( -vOPosition.xyz ) ) ) );
					base += useSSS * color * ( 1. - .75 * rim );
					base += ( 1. - useSSS ) * 10. * base * color * clamp( 1. - rim, 0., .15 );

					if( useScreen == 1. ) {
						base = vec3( 1. ) - ( vec3( 1. ) - base ) * ( vec3( 1. ) - base );
					}

					float nn = .05 * random( vec3( 1. ), length( gl_FragCoord ) );
			        base += vec3( nn );

			        gl_FragColor = vec4( base.rgb, 1. );

			    }
			</script>

			<script src="js/sequence.js"></script>
	</body>
</html>
